#! /usr/bin/perl

#**********************************************************************
#
#   Project: RC5 Crypto Engine Generator
#
#   Language: Perl 5
#
#   Developer: Saied Hosseini Khayat
#   Email:     saied.h.khayat@outlook.com
#   Date:      Oct 2002
#
#   Copyright Notice: Free use of this library is permitted under the
#   guidelines and in accordance with the most current version of the
#   Microsoft Public License (MS-PL).
#   http://opensource.org/licenses/MS-PL
#
#**********************************************************************

#######################################################################
# This is a Perl script to generate VHDL code for an RC5-w/r/b core.
#######################################################################

$author = "Saied Hosseini Khayat";
$date = "Oct 12, 2002";
$pipelined = 1;
$remark1 = "Note: This file was automatically generated by a Perl script.
--       In general you do not need to edit this file. Any permanent
--       modifications should be made to the Perl script that generated
--       this file.";

# obtain parameters from command line

die "Usage: $0 w r b \n" if ($#ARGV!=2);

$W = $ARGV[0];  # Word size  (Range: 16,32,64)
$R = $ARGV[1];  # Number of rounds (Range: 1,2,3,....,255)
$B = $ARGV[2];  # Number of key bytes (Range: 1,2,3,....,255)

# check input parameters for validity
die "Fatal: parameter out of range!\n" unless ( ($W==16 || $W==32 || $W==64) &&
                                              ( (0<$R) && ($R<256) )  &&
                                              ( (0<$B) && ($B<256) ) );

$N = 4 if ($W==16);
$N = 5 if ($W==32);
$N = 6 if ($W==64);

$T = (2*$R+2);

print "\nBuilding VHDL core for RC5-$W/$R/$B\n";

#----------------------------------
# begin building VHDL files
#----------------------------------

$file1 = "RC5_ENCRYPT_VROL.vhd";
$file2 = "RC5_DECRYPT_VROR.vhd";
$file3 = "RC5_ENCRYPT_ROUND.vhd";
$file4 = "RC5_DECRYPT_ROUND.vhd";
$file5 = "RC5_ENCRYPT_TOP.vhd";
$file6 = "RC5_DECRYPT_TOP.vhd";
$file7 = "RC5_ENCRYPT_TB.vhd";
$file8 = "RC5_DECRYPT_TB.vhd";

#====================================================================
print "   Building file $file1\n";

open (FILE,">$file1");


print FILE "
------------------------------------------------------------------------
-- MODULE: RC5_ENCRYPT_VROL
--
-- LANGUAGE: VHDL-93
--
-- AUTHOR: $author
--
-- DESCRIPTION: This module is a barrel shifter to perform
--              variable left circular rotations on a bit vector.
--
-- DATE: $date
--
-- $remark1
-----------------------------------------------------------------------

library IEEE;
use IEEE.STD_LOGIC_1164.all;

entity RC5_ENCRYPT_VROL is
    port (
        sn : in  std_logic_vector($N downto 1);  -- number of rotate steps
        di : in  std_logic_vector($W downto 1);  -- data in
        do : out std_logic_vector($W downto 1)   -- data out
    );
end entity;
";


print FILE "

architecture rtl of RC5_ENCRYPT_VROL is
    signal d0 : std_logic_vector($W downto 1);
    signal d1 : std_logic_vector($W downto 1);
    signal d2 : std_logic_vector($W downto 1);
    signal d3 : std_logic_vector($W downto 1);
    signal d4 : std_logic_vector($W downto 1);
    signal r1 : std_logic_vector($W downto 1);
    signal r2 : std_logic_vector($W downto 1);
    signal r4 : std_logic_vector($W downto 1);
    signal r8 : std_logic_vector($W downto 1); ";

print FILE"
    signal d5  : std_logic_vector($W downto 1);
    signal r16 : std_logic_vector($W downto 1); " if ( ($N==5) || ($N==6) );

print FILE "
    signal d6  : std_logic_vector($W downto 1);
    signal r32 : std_logic_vector($W downto 1); " if ( $N==6 );


print FILE "
begin -- architecture
";

print FILE "
    d0 <= di;
    d1 <= r1  when (sn(1)='1') else d0;
    d2 <= r2  when (sn(2)='1') else d1;
    d3 <= r4  when (sn(3)='1') else d2;
    d4 <= r8  when (sn(4)='1') else d3; ";

print FILE "
    d5 <= r16 when (sn(5)='1') else d4; " if ( ($N==5) || ($N==6) );

print FILE "
    d6 <= r32 when (sn(6)='1') else d5; " if ($N==6);

print FILE "
    do <= d4; " if ($N==4);

print FILE "
    do <= d5; " if ($N==5);

print FILE "
    do <= d6; " if ($N==6);

print FILE "
    r1  <= d0($W-1  downto 1) & d0($W);
    r2  <= d1($W-2  downto 1) & d1($W downto $W-1);
    r4  <= d2($W-4  downto 1) & d2($W downto $W-3);
    r8  <= d3($W-8  downto 1) & d3($W downto $W-7); ";

print FILE "
    r16 <= d4($W-16 downto 1) & d4($W downto $W-15); " if ( ($N==5) || ($N==6) );

print FILE "
    r32 <= d5($W-32 downto 1) & d5($W downto $W-31); " if ($N==6);

print FILE "
end rtl;
-- END OF FILE
";

close FILE;


#====================================================================
print "   Building file $file2\n";

open (FILE,">$file2");

print FILE "
------------------------------------------------------------------------
-- MODULE: RC5_DECRYPT_VROR
--
-- LANGUAGE: VHDL-93
--
-- AUTHOR: $author
--
-- DESCRIPTION: This module is a barrel shifter to perform
--              variable right circular rotations on a bit vector.
--
-- DATE: $date
--
-- $remark1
-----------------------------------------------------------------------

library IEEE;
use IEEE.STD_LOGIC_1164.all;

entity RC5_DECRYPT_VROR is
    port (
        sn : in  std_logic_vector($N downto 1);  -- number of rotate steps
        di : in  std_logic_vector($W downto 1);  -- data in
        do : out std_logic_vector($W downto 1)   -- data out
    );
end entity;
";


print FILE "

architecture rtl of RC5_DECRYPT_VROR is
    signal d0 : std_logic_vector($W downto 1);
    signal d1 : std_logic_vector($W downto 1);
    signal d2 : std_logic_vector($W downto 1);
    signal d3 : std_logic_vector($W downto 1);
    signal d4 : std_logic_vector($W downto 1);
    signal r1 : std_logic_vector($W downto 1);
    signal r2 : std_logic_vector($W downto 1);
    signal r4 : std_logic_vector($W downto 1);
    signal r8 : std_logic_vector($W downto 1); ";

print FILE"
    signal d5  : std_logic_vector($W downto 1);
    signal r16 : std_logic_vector($W downto 1); " if ( ($N==5) || ($N==6) );

print FILE "
    signal d6  : std_logic_vector($W downto 1);
    signal r32 : std_logic_vector($W downto 1); " if ( $N==6 );


print FILE "
begin -- architecture
 ";

print FILE "
    d0 <= di;
    d1 <= r1  when (sn(1)='1') else d0;
    d2 <= r2  when (sn(2)='1') else d1;
    d3 <= r4  when (sn(3)='1') else d2;
    d4 <= r8  when (sn(4)='1') else d3; ";

print FILE "
    d5 <= r16 when (sn(5)='1') else d4; " if ( ($N==5) || ($N==6) );

print FILE "
    d6 <= r32 when (sn(6)='1') else d5; " if ($N==6);

print FILE "
    do <= d4; " if ($N==4);

print FILE "
    do <= d5; " if ($N==5);

print FILE "
    do <= d6; " if ($N==6);

print FILE "
    r1  <= d0(1)          & d0($W downto 2);
    r2  <= d1(2 downto 1) & d1($W downto 3);
    r4  <= d2(4 downto 1) & d2($W downto 5);
    r8  <= d3(8 downto 1) & d3($W downto 9); ";


print FILE "
    r16 <= d4(16 downto 1) & d4($W downto 17); " if ( ($N==5) || ($N==6) );

print FILE "
    r32 <= d5(32 downto 1) & d5($W downto 33); " if ($N==6);


print FILE "
end rtl;
-- END OF FILE
";

close FILE;


#====================================================================
print "   Building file $file3\n";

open (FILE,">$file3");

print FILE "
------------------------------------------------------------------------
-- MODULE: RC5_ENCRYPT_ROUND
--
-- LANGUAGE: VHDL-93
--
-- AUTHOR: $author
--
-- DESCRIPTION: This module performs one round of RC5 Encryption.
--
-- DEPENDENCIES:
--           RC5_ENCRYPT_VROL.vhd
--
-- DATE: $date
--
-- $remark1
-----------------------------------------------------------------------

library IEEE;
use IEEE.STD_LOGIC_1164.all;
use IEEE.STD_LOGIC_UNSIGNED.all;

entity RC5_ENCRYPT_ROUND is
    port (
        skr : in  std_logic_vector($W   downto 1); -- right subkey
        skl : in  std_logic_vector($W   downto 1); -- left subkey
        di  : in  std_logic_vector($W*2 downto 1); -- data in
        do  : out std_logic_vector($W*2 downto 1)  -- data out
    );
end;


architecture rtl of RC5_ENCRYPT_ROUND is
    component RC5_ENCRYPT_VROL
        port (
            sn : in  std_logic_vector($N downto 1);
            di : in  std_logic_vector($W downto 1);
            do : out std_logic_vector($W downto 1)
        );
    end component;
    signal dle0, dre0 : std_logic_vector($W downto 1);
    signal dle1, dre1 : std_logic_vector($W downto 1);
    signal dle2, dre2 : std_logic_vector($W downto 1);
    signal dle3, dre3 : std_logic_vector($W downto 1);
begin

    LVROL_L: RC5_ENCRYPT_VROL port map ( sn=>dre0($N downto 1), di=>dle1, do=>dle2 );
    LVROL_R: RC5_ENCRYPT_VROL port map ( sn=>dle3($N downto 1), di=>dre1, do=>dre2 );

    dle0 <= di($W*2 downto $W+1);
    dre0 <= di($W downto 1);

    dle1 <= dre0 XOR dle0;
    dle3 <= dle2 + skl;

    dre1 <= dre0 XOR dle3;
    dre3 <= dre2 + skr;
    do <= dle3 & dre3;

end rtl;
-- END OF FILE
";

close FILE;



#====================================================================
print "   Building file $file4\n";

open (FILE,">$file4");

print FILE "
------------------------------------------------------------------------
-- MODULE: RC5_DECRYPT_ROUND
--
-- LANGUAGE: VHDL-93
--
-- AUTHOR: $author
--
-- DESCRIPTION: This module performs one round of RC5 Decryption.
--
-- DEPENDENCIES:
--           RC5_DECRYPT_VROR.vhd
--
-- DATE: $date
--
-- $remark1
-----------------------------------------------------------------------

library IEEE;
use IEEE.STD_LOGIC_1164.all;
use IEEE.STD_LOGIC_UNSIGNED.all;

entity RC5_DECRYPT_ROUND is
    port (
        skr : in  std_logic_vector($W   downto 1); -- right subkey
        skl : in  std_logic_vector($W   downto 1); -- left subkey
        di  : in  std_logic_vector($W*2 downto 1); -- data in
        do  : out std_logic_vector($W*2 downto 1)  -- data out
    );
end;


architecture rtl of RC5_DECRYPT_ROUND is
    component RC5_DECRYPT_VROR
        port (
            sn : in  std_logic_vector($N  downto 1);
            di : in  std_logic_vector($W downto 1);
            do : out std_logic_vector($W downto 1)
        );
    end component;
    signal dle0, dre0 : std_logic_vector($W downto 1);
    signal dle1, dre1 : std_logic_vector($W downto 1);
    signal dle2, dre2 : std_logic_vector($W downto 1);
    signal dle3, dre3 : std_logic_vector($W downto 1);
begin

    LVROR_R: RC5_DECRYPT_VROR port map ( sn=>dle0($N downto 1), di=>dre1, do=>dre2 );
    LVROR_L: RC5_DECRYPT_VROR port map ( sn=>dre3($N downto 1), di=>dle1, do=>dle2 );

    dle0 <= di($W*2 downto $W+1);
    dre0 <= di($W downto 1);

    dre1 <= dre0 - skr;
    dre3 <= dre2 XOR dle0;

    dle1 <= dle0 - skl;
    dle3 <= dle2 XOR dre3;
    do <= dle3 & dre3;

end rtl;
-- END OF FILE
";

close FILE;



#====================================================================
print "   Building file $file5\n";

open (FILE,">$file5");

print FILE "
------------------------------------------------------------------------
-- MODULE: RC5_ENCRYPT_TOP
--
-- LANGUAGE: VHDL-93
--
-- AUTHOR: $author
--
-- DESCRIPTION: This module is the top-level entity for RC5 Encryption.
--
-- DEPENDENCIES:
--           RC5_ENCRYPT_ROUND.vhd
--           RC5_ENCRYPT_VROL.vhd
--
-- DATE: $date
--
-- $remark1
-----------------------------------------------------------------------

library IEEE;
use IEEE.STD_LOGIC_1164.all;
use IEEE.STD_LOGIC_UNSIGNED.all;


entity RC5_ENCRYPT_TOP is
    port (
        clk : in  std_logic;
        ken : in  std_logic;                       -- key load enable
        ski : in  std_logic_vector($W   downto 1); -- subkey input port
        di  : in  std_logic_vector($W*2 downto 1); -- data input port
        do  : out std_logic_vector($W*2 downto 1)  -- data output port
    );
end;
";


print FILE "

architecture top of RC5_ENCRYPT_TOP is
    component RC5_ENCRYPT_ROUND
        port (
            skr : in  std_logic_vector($W   downto 1);
            skl : in  std_logic_vector($W   downto 1);
            di  : in  std_logic_vector($W*2 downto 1);
            do  : out std_logic_vector($W*2 downto 1)
        );
    end component;
";


for ( $i=0; $i<=$T-1; $i++ ) {
print FILE "
    signal sk$i : std_logic_vector($W downto 1); -- subkey register";
}

for ( $i=0; $i<=$R; $i++ ) {
print FILE "
    signal reg$i, dat$i: std_logic_vector($W*2 downto 1); -- data pipeline";
}


print FILE "
    signal di_reg, do_reg : std_logic_vector($W*2 downto 1); -- data boundary registers
    signal le, re : std_logic_vector($W downto 1);
begin -- architecture
";

print FILE "
    -- process to load subkeys
    LLOAD: process
    begin
        wait until rising_edge(clk);
        if ken='1' then";

$Tminus1 = $T-1;

for ( $i=0; $i<$T-1; $i++ ) {
    $j = $i+1;
    print FILE "
            sk$i <= sk$j;";
}

print FILE "
            sk$Tminus1 <= ski;
        end if;
    end process;

";

print FILE "
    le <= di_reg($W*2 downto $W+1) + sk0;
    re <= di_reg($W   downto    1) + sk1;

    dat0 <= le & re;
";

if ($pipelined) {
    print FILE "
    -- data pipeline
    process
    begin
        wait until rising_edge(clk); ";

    for ($i=0; $i<=$R; $i++) {
        print FILE "
        reg$i <= dat$i; ";
    }

    print FILE "
    end process; ";
}
else {

    for ($i=0; $i<=$R; $i++) {
        print FILE "
    reg$i <= dat$i; ";
    }
}

print FILE "

    -- all rounds in tandem";

for ($i=1; $i<=$R; $i++) {
    $j = $i-1;
    $k = $i*2;
    $m = $i*2+1;
    print FILE "
    LROUND_$i: RC5_ENCRYPT_ROUND
               port map ( skr=>sk$m, skl=>sk$k, di=>reg$j, do=>dat$i ); ";
}

print FILE "

    -- data boundary registers
    process
    begin
        wait until rising_edge(clk);
        di_reg <= di;
        do_reg <= reg$R;
    end process;

    do <= do_reg;

end top;

-- END OF FILE

";


close FILE;



#====================================================================
print "   Building file $file6\n";

open (FILE,">$file6");

print FILE "
------------------------------------------------------------------------
-- MODULE: RC5_DECRYPT_TOP
--
-- LANGUAGE: VHDL-93
--
-- AUTHOR: $author
--
-- DESCRIPTION: This module is the top entity for RC5 Decryption.
--
-- DEPENDENCIES:
--           RC5_DECRYPT_ROUND.vhd
--           RC5_DECRYPT_VROR.vhd
--
-- DATE: $date
--
-- $remark1
-----------------------------------------------------------------------

library IEEE;
use IEEE.STD_LOGIC_1164.all;
use IEEE.STD_LOGIC_UNSIGNED.all;

entity RC5_DECRYPT_TOP is
    port (
        clk : in  std_logic;
        ken : in  std_logic;                       -- key enable
        ski : in  std_logic_vector($W   downto 1); -- subkey input port
        di  : in  std_logic_vector($W*2 downto 1); -- data input port
        do  : out std_logic_vector($W*2 downto 1)  -- data output port
    );
end;



architecture top of RC5_DECRYPT_TOP is
    component RC5_DECRYPT_ROUND
        port (
            skr : in  std_logic_vector($W   downto 1);
            skl : in  std_logic_vector($W   downto 1);
            di  : in  std_logic_vector($W*2 downto 1);
            do  : out std_logic_vector($W*2 downto 1)
        );
    end component;
";

$T = (2*$R+2);

for ( $i=0; $i<=$T-1; $i++ ) {
    print FILE "
    signal sk$i : std_logic_vector($W downto 1); -- subkey register";
}

for ( $i=0; $i<=$R; $i++ ) {
    print FILE "
    signal reg$i, dat$i: std_logic_vector($W*2 downto 1); -- data pipeline";
}


print FILE "
    signal le, re : std_logic_vector($W downto 1);
    signal do_pre : std_logic_vector($W*2 downto 1);
    signal di_reg, do_reg : std_logic_vector($W*2 downto 1); -- data boundary registers
begin -- architecture

    -- process to load subkeys
    LLOAD: process
    begin
        wait until rising_edge(clk);
        if ken='1' then";

$Tminus1 = $T-1;

for ( $i=0; $i<$T-1; $i++ ) {
    $j = $i+1;
    print FILE "
            sk$i <= sk$j;";
}

print FILE "
            sk$Tminus1 <= ski;
        end if;
    end process;

";


if ($pipelined) {
    print FILE "
    -- data pipeline
    process
    begin
        wait until rising_edge(clk); ";

    for ($i=0; $i<=$R; $i++) {
        print FILE "
        reg$i <= dat$i; ";
    }

    print FILE "
        dat$R <= di_reg;
    end process; ";
}
else {

    for ($i=0; $i<=$R; $i++) {
        print FILE "
    reg$i <= dat$i; ";
    }
    print FILE "
    dat$R <= di_reg; ";
}


print FILE "

    -- all rounds in tandem";

for ($i=1; $i<=$R; $i++) {
    $j = $i-1;
    $k = $i*2;
    $m = $i*2+1;
    print FILE "
    LROUND_$i: RC5_DECRYPT_ROUND
               port map ( skr=>sk$m, skl=>sk$k, di=>reg$i, do=>dat$j ); ";
}


print FILE "

    do_pre <= reg0;
    le <= do_pre($W*2 downto $W+1) - sk0;
    re <= do_pre($W downto 1) - sk1;

    -- data boundary register
    process
    begin
        wait until rising_edge(clk);
        di_reg <= di;
        do_reg <= le & re;
    end process;

    do <= do_reg;

end top;

-- END OF FILE
";


close FILE;



#====================================================================
print "   Building file $file7\n";

open (FILE,">$file7");

print FILE "
------------------------------------------------------------------------
-- MODULE: RC5_ENCRYPT_TB
--
-- LANGUAGE: VHDL-93
--
-- AUTHOR: $author
--
-- DESCRIPTION: This module is the testbench for RC5_ENCRYPT_TOP.
--
-- DEPENDENCIES:
--           RC5_ENCRYPT_VROL.vhd
--           RC5_ENCRYPT_ROUND.vhd
--           RC5_ENCRYPT_TOP.vhd
--
-- DATE: $date
--
-- $remark1
-----------------------------------------------------------------------

library IEEE;
use IEEE.STD_LOGIC_1164.all;
use STD.TEXTIO.all;
use IEEE.STD_LOGIC_TEXTIO.all;


entity RC5_ENCRYPT_TB is
    generic ( T        : time   := 10 ns ;
              infile   : string := \"rc5_encrypt_tb.in\";
              outfile  : string := \"rc5_encrypt_tb.out\";
              keyfile  : string := \"rc5_encrypt_tb.key\" );
end entity;



architecture test of RC5_ENCRYPT_TB is
    signal clk       : std_logic:='0';
    signal ski       : std_logic_vector($W downto 1);
    signal enable    : std_logic := 'U';
    signal ciphertxt : std_logic_vector($W*2 downto 1);
    signal plaintxt  : std_logic_vector($W*2 downto 1) := (others=>'0');

    file kfp : text open read_mode  is keyfile;
    file ifp : text open read_mode  is infile;
    file ofp : text open write_mode is outfile;

    constant D : time := 1 ns;
begin -- architecture

    DUT: entity work.RC5_ENCRYPT_TOP(top)
         port map (
            clk => clk,
            ken => enable,
            ski => ski,
            di  => plaintxt,
            do  => ciphertxt
         );


    -- process to generate clock signal
    process
    begin
        clk <= not clk;
        wait for T/2;
    end process;


    -- process to set up subkeys
    process
        variable L : line;
        variable bv : std_logic_vector($W downto 1);
    begin
        wait until rising_edge(clk);
        wait until rising_edge(clk);
        wait until rising_edge(clk);
        wait until rising_edge(clk);
        wait until rising_edge(clk);
        enable <= '1' after D;

        for i in 0 to $T-1 loop
            wait until rising_edge(clk);
            readline(kfp,L); -- read subkey from file
            read(L,bv);
            ski <= bv after D; -- send to RC5_ENCRYPT_TOP
        end loop;

        wait until rising_edge(clk);
        enable <= '0' after D;
        wait; -- halt this process
    end process;


    -- encrypt some plaintext words from the input file
    process
        variable L : line;
        variable bv : std_logic_vector($W*2 downto 1);
    begin
        wait until enable='1';
        wait for ($T+20)*T;

        while not endfile(ifp) loop
            readline(ifp,L);
            read(L,bv); -- read plaintext bit vector
            write(L,ciphertxt);
            writeline(ofp,L);
            wait until rising_edge(clk);
            plaintxt <= bv after D;
        end loop;
        wait;
    end process;


end test;

-- END OF FILE
";



#====================================================================
print "   Building file $file8\n";

open (FILE,">$file8");

print FILE "

------------------------------------------------------------------------
-- MODULE: RC5_DECRYPT_TB
--
-- LANGUAGE: VHDL-93
--
-- AUTHOR: $author
--
-- DESCRIPTION: This module is the testbench for RC5_DECRYPT_TOP.
--
-- DEPENDENCIES:
--           RC5_DECRYPT_VROR.vhd
--           RC5_DECRYPT_ROUND.vhd
--           RC5_DECRYPT_TOP.vhd
--
-- DATE: $date
--
-- $remark1
-----------------------------------------------------------------------

library IEEE;
use IEEE.STD_LOGIC_1164.all;
use STD.TEXTIO.all;
use IEEE.STD_LOGIC_TEXTIO.all;


entity RC5_DECRYPT_TB is
    generic ( T        : time   := 10 ns ;
              infile   : string := \"rc5_decrypt_tb.in\";
              outfile  : string := \"rc5_decrypt_tb.out\";
              keyfile  : string := \"rc5_decrypt_tb.key\" );
end ;



architecture test of RC5_DECRYPT_TB is
    signal clk       : std_logic:='0';
    signal ski       : std_logic_vector($W downto 1);
    signal enable    : std_logic := '0';
    signal ciphertxt : std_logic_vector($W*2 downto 1);
    signal plaintxt  : std_logic_vector($W*2 downto 1) := (others=>'0');

    file kfp : text open read_mode  is keyfile;
    file ifp : text open read_mode  is infile;
    file ofp : text open write_mode is outfile;

    constant D : time := 1 ns;
begin -- architecture

    DUT: entity work.RC5_DECRYPT_TOP(top)
         port map (
            clk => clk,
            ken => enable,
            ski => ski,
            di  => ciphertxt,
            do  => plaintxt
         );


    -- process to generate clock signal
    process
    begin
        clk <= not clk;
        wait for T/2;
    end process;


    -- process to set up subkeys
    process
        variable L : line;
        variable bv : std_logic_vector($W downto 1);
    begin
        wait for 10*T;
        enable <= '1' after D;

        for i in 0 to $T-1 loop
            readline(kfp,L); -- read subkey from file
            read(L,bv);
            wait until rising_edge(clk);
             ski <= bv after D; -- send to RC5_DECRYPT
        end loop;

        wait until rising_edge(clk);
        enable <= '1' after D;
        wait; -- halt this process
    end process;


    -- process to decrypt some ciphertext words
    process
        variable L : line;
        variable bv : std_logic_vector($W*2 downto 1);
    begin
        wait until enable='1'; -- wait until
        wait for ($T+20)*T;

        while not endfile(ifp) loop
            readline(ifp,L);
            read(L,bv); -- read ciphertext bit vector
            write(L,plaintxt);
            writeline(ofp,L);
            wait until rising_edge(clk);
            ciphertxt <= bv after D;
        end loop;
        wait;
    end process;


end test;

-- END OF FILE
";


print "\nAll Done!\n";

# END OF PERL SCRIPT
__END__
